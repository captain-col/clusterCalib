Define the constant runtime parameters.  These are the parameters that
should not be looked up from a database.

Define the maximum length of a shaped pulse.  The exact value isn't
important, but should be considerably longer than a pulse.  There is a
trade off since smaller values will run slightly faster.

< clusterCalib.digitization.pulse = 20000 ns >

Define the maximum length of the impulse response function.  The exact
value isn't important as long as it is longer than the response function.
There is a trade off since smaller values will run slightly faster.

< clusterCalib.digitization.response = 20000 ns >

After the wire channels are calibrated, the output FADC signals are
analyzed for peaks using TSpectrum::SearchHighRes() using a very loose
acceptance criteria.  Peaks found by the search are then examined to see if
they are consistent with a real peak.  These parameters control the peak
acceptance.  The charge is the charge value at the peak.  The deconvolution
is the estimated power from the SearchHighRes() output.  The noise is the
number of RMS sigma above the random noise before peak is taken as signal.

The charge value in the calibrated charge histogram after the response
function has been deconvolved.  The units are in collected electrons

< clusterCalib.peakSearch.charge = 7000 >

The area as estimated by TSpectrum.  The units are in collected electrons.

< clusterCalib.peakSearch.area = 7000 >

Limit peaks that are close to the measured noise in the event.  If it's
less than this, it's assumed to be random noise.

< clusterCalib.peakSearch.noise = 0.0 >

The number of samples to skip when searching for wire hits.  This avoids a
problem with "FFT wrap around", and because of the trigger, there shouldn't
be hits there anyway.

< clusterCalib.peakSearch.endSkip = 500 >

Set the limit on how wide a time cluster can be before the cluster is split
into multiple hits.

< clusterCalib.peakSearch.rmsLimit = 4000000 ns >

Set the amount of time domain smoothing to be applied to the input signal
before applying the deconvolution.  The value controls the number of
"side-band" samples to use when smoothing a particular sample.  A value of
zero means no smoothing.

< clusterCalib.deconvolution.smoothing = 0 >

The pulse deconvolution will remove the baseline from the pulse.  The base
line is determined by runs of coherenceZone samples with fluctuations of
less that sigma*fluctuationCut.  The sigma is the sigma of the
sample-to-sample variations.  

< clusterCalib.deconvolution.coherenceZone = 10 >
< clusterCalib.deconvolution.fluctuationCut = 3 >

The cut in standard deviations used to find spikes in the FFT.  Large
spikes are at fixed frequencies and are filtered..

< clusterCalib.deconvolution.spikePower = 5.0 >

The weight to be applied to the "power" in the noise model used by the
filter.  This should have a value "near" to one.

< clusterCalib.deconvolution.noisePower = 1.0 >

The number of samples inside the coherence zone that vary less than
fluctuationCut.  If the number is less than this cut, the region is not
considered baseline.

< clusterCalib.deconvolution.coherenceCut = 10 >

The baseline can follow a random walk, but if the estimate gets more than
the this cut times the sigma of the baseline then assume it's actually
signal.

< clusterCalib.deconvolution.baselineCut = 5 >

The threshold for a PMT hit.  The PMT signals are calibrated so that the
integral of a 1 pe pulse is 1.0, so the peak is typically around 0.05, and
the noise level is around 0.005.

< clusterCalib.pmt.threshold = 0.05 >

The collection efficiency for each of the types of wires in the MC.  These
are used to tune the overall response of the wires (and should be 1.0)

< clusterCalib.mc.wire.collection.x = 1.0 > 
< clusterCalib.mc.wire.collection.v = 1.0 > 
< clusterCalib.mc.wire.collection.u = 1.0 > 

