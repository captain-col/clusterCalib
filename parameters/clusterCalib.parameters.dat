Define the constant runtime parameters.  These are the parameters that
should not be looked up from a database.

Define the maximum length of a shaped pulse.  The exact value isn't
important, but should be considerably longer than a pulse.  There is a
trade off since smaller values will run slightly faster.

< clusterCalib.digitization.pulse = 20000 ns >

Define the maximum length of the impulse response function.  The exact
value isn't important as long as it is longer than the response function.
There is a trade off since smaller values will run slightly faster.

< clusterCalib.digitization.response = 20000 ns >

After the wire channels are calibrated, the output FADC signals are
analyzed for peaks using TSpectrum::SearchHighRes() using a very loose
acceptance criteria.  Peaks found by the search are then examined to see if
they are consistent with a real peak.  These parameters control the peak
acceptance.  The charge is the charge value at the peak.  The deconvolution
is the estimated power from the SearchHighRes() output.  The noise is the
number of RMS sigma above the random noise before peak is taken as signal.

The charge value in the calibrated charge histogram after the response
function has been deconvolved.  The units are in collected electrons

< clusterCalib.peakSearch.charge.collection = 100 >
< clusterCalib.peakSearch.charge.induction = 100 >

The area as estimated by TSpectrum.  The units are in collected electrons.

< clusterCalib.peakSearch.area.collection = 3000 >
< clusterCalib.peakSearch.area.induction = 3000 >

The peak search needs to assume a width with it is starting.  The width
should be approximately the RMS of the narrowest "real" peak, but isn't
extremely sensitive.  The better this estimate is, the better the search
will work.

< clusterCalib.peakSearch.width.collection = 650 >
< clusterCalib.peakSearch.width.induction = 1300 >

Limit peaks that are close to the measured noise in the event.  If it's
less than this, it's assumed to be random noise.

< clusterCalib.peakSearch.noise = 7.0 >

The number of samples to skip when searching for wire hits.  This avoids a
problem with "FFT wrap around", and because of the trigger, there shouldn't
be hits there anyway.

< clusterCalib.peakSearch.endSkip = 500 >

Set the limit on how wide a time cluster can be before the cluster is split
into multiple hits.

< clusterCalib.peakSearch.rmsLimit = 4000000 ns >

Set the amount of time domain smoothing to be applied to the input signal
before applying the deconvolution.  The value controls the number of
"side-band" samples to use when smoothing a particular sample.  A value of
zero means no smoothing.

< clusterCalib.deconvolution.smoothing = 0 >

The pulse deconvolution will remove the baseline from the pulse.  The base
line is determined by runs of coherenceZone samples with fluctuations of
less that sigma*fluctuationCut.  The sigma is the sigma of the
sample-to-sample variations.  

< clusterCalib.deconvolution.coherenceZone = 10 >
< clusterCalib.deconvolution.fluctuationCut = 3 >

The cut in standard deviations used to find spikes in the FFT.  Large
spikes are at fixed frequencies and are filtered.  A larger spikePower
means more filtering.  This is disabled if it's negative.

< clusterCalib.deconvolution.spikePower = 1.0 >

The weight to be applied to the "power" in the noise model used by the
filter.  This should have a value "near" to one.

< clusterCalib.deconvolution.noisePower = 1.0 >

The number of samples inside the coherence zone that vary less than
fluctuationCut.  If the number is less than this cut, the region is not
considered baseline.

< clusterCalib.deconvolution.coherenceCut = 10 >

The baseline can follow a random walk, but if the estimate gets more than
the this cut times the sigma of the baseline then assume it's actually
signal.

< clusterCalib.deconvolution.baselineCut = 5 >

The threshold for a PMT hit.  The PMT signals are calibrated so that the
integral of a 1 pe pulse is 1.0, so the peak is typically around 0.05, and
the noise level is around 0.005.

< clusterCalib.pmt.threshold = 0.05 >

The collection efficiency for each of the types of wires in the MC.  These
are used to tune the overall response of the wires (and should be 1.0)

< clusterCalib.mc.wire.collection.x = 1.0 > 
< clusterCalib.mc.wire.collection.v = 1.0 > 
< clusterCalib.mc.wire.collection.u = 1.0 > 

Define the activity filter to determine if an event should be run through
the full calibration and hit finding.  The filter can be turned on or off
by using the "-O filter" option from the clusterCalib command line.  The
required channels are the number of channels that must have activity.  The
required significance is the number of "sigma" a channel must be above the
base line to be considered active.  The minimum signal is the minimum
threshold in ADC counts to be considered active.

< clusterCalib.filter.requiredChannels = 6 >
< clusterCalib.filter.requiredSignificance = 7.0 >
< clusterCalib.filter.minimumSignal = 30 >


