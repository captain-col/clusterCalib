Define the constant runtime parameters.  These are the parameters that
should not be looked up from a database.

Define the time per digit in the TPulseDigit.  This specifies the minimum
and is used to calculate the number of bins in the FFT.  The exact value
isn't important, but it should be shorter (or at least equal to) the
sampling time.  This does not control the actual calibration since the
digitization step for a particular channel is found from the database (or
was specified in elecSim for the MC).  The value of 250 is chosen since
that the minimum step allowed by the electronics.  The normal value is 500.

< clusterCalib.digitization.step = 250 ns >

Define the maximum length of a shaped pulse.  The exact value isn't
important, but should be considerably longer than a pulse.  There is a
trade off since smaller values will run slightly faster.

< clusterCalib.digitization.pulse = 100000 ns >

Define the maximum length of the impulse response function.  The exact
value isn't important as long as it is longer than the response function.
There is a trade off since smaller values will run slightly faster.

< clusterCalib.digitization.response = 100000 ns >

After the wire channels are calibrated, the output FADC signals are
analyzed for peaks using TSpectrum::SearchHighRes() using a very loose
acceptance criteria.  Peaks found by the search are then examined to see if
they are consistent with a real peak.  These parameters control the peak
acceptance.  The charge is the charge value at the peak.  The deconvolution
is the estimated power from the SearchHighRes() output.  The noise is the
number of RMS sigma above the random noise the signal needs to be.

< clusterCalib.peakSearch.charge = 1000 >
< clusterCalib.peakSearch.deconvolution = 4000 >
< clusterCalib.peakSearch.noise = 5.0 >

Set the limit on how wide a time cluster can be before the cluster is split
into multiple hits.

< clusterCalib.peakSearch.rmsLimit = 4000 ns >

Set the amount of time domain smoothing to be applied to the input signal
before applying the deconvolution.  The value controls the number of
"side-band" samples to use when smoothing a particular sample.  A value of
zero means no smoothing.

< clusterCalib.deconvolution.smoothing = 0 >

The pulse deconvolution will remove the baseline from the pulse.  The base
line is determined by runs of coherenceZone samples with fluctuations of
less that sigma*fluctuationCut.  The sigma is the sigma of the
sample-to-sample variations.  

< clusterCalib.deconvolution.coherenceZone = 10 >
< clusterCalib.deconvolution.fluctuationCut = 3 >

An filter can be applied to reduce the effect of noise.  This
sets the frequency cut-off as a fraction of the Nyquist frequency.  A
"cut" of 1.0 means no cut-off.  Since the Nyquist frequency is
nominally 1 MHz and our signal is about 500 kHz (i.e. half the Nyquist
frequency), the nominal cut value will probably be somewhere between
0.8 and 0.95.

< clusterCalib.deconvolution.nyquistFraction = -0.75 >

The amount of "power" in the noise model used by the filter.  This should
have a value "near" to one.

< clusterCalib.deconvolution.noisePower = 0.10 >

The number of samples inside the coherence zone that vary less than
fluctuationCut.  If the number is less than this cut, the region is not
considered baseline.

< clusterCalib.deconvolution.coherenceCut = 10 >

The baseline can follow a random walk, but if the estimate gets more than
the this cut times the sigma of the baseline then assume it's actually
signal.

< clusterCalib.deconvolution.baselineCut = 5 >

The threshold for a PMT hit.  The PMT signals are calibrated so that the
integral of a 1 pe pulse is 1.0, so the peak is typically around 0.05, and
the noise level is around 0.005.

< clusterCalib.pmt.threshold = 0.05 >

The collection efficiency for each of the types of wires in the MC.  These
were calculated using CLUSTERCALIB.exe -O no-efficiency.

< clusterCalib.mc.wire.collection.x = 1.0 > 
< clusterCalib.mc.wire.collection.v = 4.29 > 
< clusterCalib.mc.wire.collection.u = 4.29 > 

